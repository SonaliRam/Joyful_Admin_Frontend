<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CSV Upload - Admin Autofill</title>
    <link rel="stylesheet" href="global.css" />
    <style>
        body {
            padding: 2rem;
            font-family: sans-serif;
        }

        .preview-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
        }

        .preview-table th,
        .preview-table td {
            border: 1px solid #ccc;
            padding: 8px;
        }

        .actions {
            margin-top: 1rem;
            display: flex;
            gap: 1rem;
        }
    </style>
</head>

<body>
    <h2>üìÅ Bulk Upload CSV</h2>
    <input type="file" id="csvInput" accept=".csv" />
    <div class="actions">
        <button onclick="autofillForms()">üìù Autofill Forms</button>
        <button onclick="submitBulkData()">üöÄ Submit All</button>
    </div>
    <table id="previewTable" class="preview-table"></table>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script>
        /* ----------------------------- globals ----------------------------- */
        let structuredData = [];            // Category-centric tree
        const CAT_URL = "http://localhost:8080/categories";
        const SUB_URL = "http://localhost:8080/subcategories";
        const PROD_URL = "http://localhost:8080/products";

        /* ------------------------- CSV ‚Üí data model ------------------------ */
        function handleCSVData(csvRows) {
            structuredData = [];
            const header = csvRows[0];

            for (let i = 1; i < csvRows.length; i++) {
                const row = csvRows[i]; if (row.length === 1 && row[0] === "") continue;
                const r = {}; header.forEach((h, j) => (r[h.trim()] = row[j]?.trim()));

                /* -------- Category -------- */
                let cat = structuredData.find(c => c.name === r.CategoryName);
                if (!cat) {
                    cat = {
                        name: r.CategoryName,
                        description: r.CategoryDesc,
                        searchkeywords: r.CategorySearch,
                        imagelink: r.CategoryImage,
                        seotitle: r.CategorySeoTitle,
                        seokeywords: r.CategorySeoKeywords,
                        seodescription: r.CategorySeoDesc,
                        published: r.CategoryPublished?.toLowerCase() !== "false",
                        subcategories: []
                    };
                    structuredData.push(cat);
                }

                /* -------- Subcategory ------ */
                let sub = cat.subcategories.find(s => s.name === r.SubcategoryName);
                if (!sub) {
                    sub = {
                        name: r.SubcategoryName,
                        imagepath: r.SubcategoryImage,
                        metatitle: r.SubcategoryMetaTitle,
                        ispublished: r.SubcategoryPublished?.toLowerCase() !== "false",
                        description: r.SubcategoryDesc,
                        metadescription: r.SubcategoryMetaDesc,
                        seokeywords: r.SubcategoryKeywords,
                        products: []
                    };
                    cat.subcategories.push(sub);
                }

                /* -------- Product ---------- */
                if (r.ProductName) {
                    let variantsObj = {};
                    if (r.ProductVariantsMap) {
                        try { variantsObj = JSON.parse(r.ProductVariantsMap); }
                        catch { console.warn("Bad variantsMap JSON on row", i + 1); }
                    }
                    sub.products.push({
                        name: r.ProductName,
                        description: r.ProductDesc,
                        mainimage: r.ProductImage,
                        producttags: r.ProductTags?.split(/[,;]/).map(t => t.trim()).filter(Boolean) || [],
                        filter: r.ProductFilter,
                        metatitle: r.ProductMetaTitle,
                        metadescription: r.ProductMetaDesc,
                        pagekeywords: r.ProductKeywords,
                        ispublished: r.ProductPublished?.toLowerCase() !== "false",
                        variantsMap: variantsObj            // keep as object
                    });
                }
            }
            renderPreview();
        }

        /* ---------------------------- Preview UI --------------------------- */
        function renderPreview() {
            const t = document.getElementById("previewTable");
            const bodyRows = structuredData.map(c => `
    <tr>
      <td>${c.name}</td>
      <td>${c.subcategories.map(s => s.name).join("<br>")}</td>
      <td>${c.subcategories.flatMap(s => s.products.map(p => p.name)).join("<br>")}</td>
    </tr>`).join("");

            t.innerHTML = `
    <thead>
      <tr><th>Category</th><th>Subcategories</th><th>Products</th></tr>
    </thead>
    <tbody>${bodyRows}</tbody>`;
        }

        /* ---------------------------- CSV loader --------------------------- */
        document.getElementById("csvInput").addEventListener("change", e => {
            const file = e.target.files[0]; if (!file) return;
            Papa.parse(file, { complete: res => handleCSVData(res.data) });
        });

        /* ----------------------------- Autofill ---------------------------- */
        function autofillForms() {
            localStorage.setItem("autofillData", JSON.stringify(structuredData));
            window.location.href = "Category.html";
        }

        /* -------------------------- Bulk submit ---------------------------- */
        async function submitBulkData() {
            try {
                for (const cat of structuredData) {
                    /* 1Ô∏è‚É£ Category */
                    const savedCat = await postJSON(CAT_URL, {
                        name: cat.name, description: cat.description, searchkeywords: cat.searchkeywords,
                        imagelink: cat.imagelink, seotitle: cat.seotitle,
                        seokeywords: cat.seokeywords, seodescription: cat.seodescription,
                        published: cat.published
                    });

                    for (const sub of cat.subcategories) {
                        /* 2Ô∏è‚É£ Subcategory */
                        const savedSub = await postJSON(SUB_URL, {
                            name: sub.name, imagepath: sub.imagepath, metatitle: sub.metatitle,
                            ispublished: sub.ispublished, description: sub.description,
                            metadescription: sub.metadescription, seokeywords: sub.seokeywords,
                            categoryIds: [savedCat.id]
                        });

                        for (const prod of sub.products) {
                            /* 3Ô∏è‚É£ Product */
                            await postJSON(PROD_URL, {
                                name: prod.name, description: prod.description, mainimage: prod.mainimage,
                                producttags: prod.producttags, filter: prod.filter,
                                metatitle: prod.metatitle, metadescription: prod.metadescription,
                                pagekeywords: prod.pagekeywords, ispublished: prod.ispublished,
                                variantsMap: JSON.stringify(prod.variantsMap),
                                subcategoryIds: [savedSub.id]
                            });
                        }
                    }
                }
                alert("‚úÖ All rows imported successfully!");
            } catch (err) {
                console.error(err);
                alert("‚ùå Import failed: " + err.message);
            }
        }

        /* ---------------------------- helpers ------------------------------ */
        const postJSON = (url, obj) => fetch(url, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(obj)
        }).then(r => {
            if (!r.ok) throw new Error(`${url} ‚Üí ${r.status}`);
            return r.json();
        });

    </script>
</body>

</html>